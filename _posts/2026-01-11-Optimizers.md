---
layout: post
title: オプティマイザ
date: 2026-01-11 17:00 +0900
description: ''
category: ['Machine Learning', 'deep-learning-from-scratch-5']
tags: [Machine Learning, deep-learning-from-scratch-5]
published: true
math: true
lang: ja
ref: Optimizers
---

[ゼロから作るDeep Learning 5](https://www.oreilly.co.jp/books/9784814400591/) を読むのに勉強したことのメモ


前回のポストの続きで、RMSProp, AdaGrad, AdaDelta, Adamについてまとめました。


## Momentumの課題

これまで説明してきたように、最適な学習率は誤差曲面の局所的な曲率に依存する。さらに、この曲率はパラメータ空間の方向によって異なる場合があり、急峻な方向では振動を防ぐために小さな学習率が望ましく、緩やかな方向では速く収束させるために大きな学習率を設定することが望ましい。しかし、標準的な勾配降下法では全てのパラメータに対して同じ学習率 $$\eta$$ を使用するため、パラメータ空間上の点ごとに曲率を調べて、学習率を適切に変化させることは難しい。

そこで、ネットワーク内の各パラメータに対して異なる学習率を使用し、それらの値を訓練中に自動的に調整するアルゴリズムが開発されてきた。

---

## AdaGrad（Adaptive Gradient）

あるパラメータに対する勾配が常に大きい場合、それは誤差曲面がそのパラメータの方向に急峻であることを示唆している。このような場合、学習率を小さくしてパラメータの更新幅を小さくする必要がある。逆に、勾配が小さいパラメータは、より大きな学習率で更新しても安全であると考えられる。AdaGradでは、各パラメータに対して計算された全ての勾配の二乗の累積和を使用して、時間とともに各学習率パラメータを減少させる。


### 更新式

まず、各パラメータ $$w_i$$ に対して、過去の勾配の二乗を累積する変数 $$r_i$$ を用意する。$$r_i$$ は、以下のように更新される。


$$r_i^{(\tau)} = r_i^{(\tau-1)} + \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)^2$$

次に、この累積値を使用してパラメータを更新する。


$$w_i^{(\tau)} = w_i^{(\tau-1)} - \frac{\eta}{\sqrt{r_i^{\tau} + \delta}} \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)$$

- $$\eta$$: 学習率
- $$\delta$$: ゼロ除算を避けるための小さな定数



勾配の2乗の累積値は、 $$r_i^{(0)} = 0$$ で初期化する。


この更新式は標準的な確率的勾配降下法に近いが、各パラメータに固有の実効学習率

$$\eta / \sqrt{r_i^{\tau} + \delta}$$
を持っており、勾配の2乗の累積値が大きいほど更新幅が小さくなる。これによって、急峻な勾配を持つパラメータの実効学習率を選択的に低下させることができる。

### AdaGradの問題点

AdaGradでは、訓練の最初から勾配の2乗を累積し続けるため、$$r_i$$ は単調に増加する。その結果、実効的な学習率 $$\eta / \sqrt{r_i + \delta}$$ は時間とともに単調に減少し、ゼロに近づいていく。


訓練の後半では、学習率が小さくなりすぎて、パラメータがほとんど更新されなくなる可能性があり、最適解に到達する前に訓練が事実上停止してしまうことがあり得る。
この問題を解決するために、RMSPropとAdaDeltaが提案された。


## RMSProp（Root Mean Square Propagation）

RMSPropでは、AdaGradの二乗勾配の単純な累積和を指数加重平均に置き換えることで、学習率が単調に減少していく問題を解決した。


### 更新式

RMSPropの更新式は以下

$$r_i^{(\tau)} = \beta r_i^{(\tau-1)} + (1 - \beta) \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)^2$$

$$w_i^{(\tau)} = w_i^{(\tau-1)} - \frac{\eta}{\sqrt{r_i^{\tau} + \delta}} \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)$$

ここで $$\beta$$ は一つ前のタイムステップの累積値と二乗勾配の混率を決める係数であり、  $$0 < \beta < 1$$ を満たす。典型的な値として $$\beta = 0.9$$ がよく用いられる。


### 指数加重平均の利点

指数加重平均を使用することで、古い勾配の情報が徐々に薄まり、最近の勾配情報がより重視されるようになる。これにより、AdaGradの問題である学習率の過度な減少を防ぐことができる。

指数加重平均は過去の全ての値を考慮するが、時間が経つにつれて古い累積和には $$\beta$$ が繰り返しかけられるため、重みが指数関数的に減衰する。

### AdaGradとの比較

AdaGradでは、二乗勾配を$$g_i^2$$ とすると、


$$r_i^{(\tau)} = r_i^{(\tau-1)} + g_i^2$$


RMSPropでは、


$$
r_i^{(\tau)} = \beta r_i^{(\tau-1)} + (1-\beta) g_i^2
$$ 


となり、過去の二乗勾配は係数 $$\beta$$ で減衰していく。


例えば、$$\beta = 0.9$$ で10ステップ前の情報は、現在の情報の約 $$0.9^{10} \approx 0.35$$ 倍の重みに減衰される。これにより、$$r_i$$ が無限に増加することなく、最近の勾配情報をよく反映した値に収束する。


## AdaDelta

AdaGradの問題点を解決するために提案されたもう一つのアルゴリズムとして、AdaDeltaが挙げられる。RMSPropと同様に指数加重移動平均を使用するが、AdaDeltaでは学習率パラメータ $$\eta$$ を明示的に設定しないことが大きな特徴である。

### 単位の一貫性

勾配を $$g$$ としたとき、標準的な勾配降下法の更新式 


$$
\Delta w = -\eta \cdot g
$$

について考える。左辺の $$\Delta w$$ はパラメータの変化量であり、パラメータと同じ単位を持つ。一方で、右辺の勾配 $$g = \partial E / \partial w$$ は、誤差関数（無次元と仮定）を重みで微分したものであり、単位が一致していない。したがって、学習率 $$\eta$$ は単位の次元を合わせるために必要。著者らは、これが学習率を手動で設定する必要がある理由の一つになっていると主張している。


### 更新式

AdaDeltaでは、二乗勾配の指数加重移動平均に加えて、パラメータ更新量の二乗の指数加重移動平均も利用する。


まず、RMSPropと同様に、二乗勾配の指数加重移動平均を計算する。


$$
r_i^{(\tau)} = \rho \ r_i^{(\tau-1)} + (1 - \rho) \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)^2
$$


次に、パラメータ変化量の二乗の指数加重移動平均を計算する。


$$
s_i^{(\tau)} = \rho \ s_i^{(\tau-1)} + (1 - \rho) \left( \Delta w_i^{(\tau-1)} \right)^2
$$


これらを用いて、RMS（Root Mean Square）の値を定義する。


$$
\text{RMS}[g]_i^{(\tau)} = \sqrt{r_i^{(\tau)} + \delta}
$$

$$
\text{RMS}[\Delta w]_i^{(\tau)} = \sqrt{s_i^{(\tau)} + \delta}
$$


これらを利用し、最終的なパラメータの更新式を得る。


$$
\Delta w_i^{(\tau)} = - \frac{\text{RMS}[\Delta w]_i^{(\tau-1)}}{\text{RMS}[g]_i^{(\tau)}} \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)
$$

$$w_i^{(\tau)} = w_i^{(\tau-1)} + \Delta w_i^{(\tau)}$$

ここで $$\rho$$ は減衰率で、典型的には $$\rho = 0.95$$ が利用される。

### AdaDeltaの特徴


単位についてみてみると、分子の $$\text{RMS}[\Delta w]$$ はパラメータと同じ単位を持ち、分母の $$\text{RMS}[g]$$ は勾配と同じ単位を持つ。このことから、$$\text{RMS}[g]$$ と勾配 $$\frac{\partial E(\mathbf{w})}{\partial w_i}$$ の積が無次元となり、単位がパラメータで一致することが分かる。

また、初期段階では $$s_i$$ がゼロに近いため更新が小さく始まり、訓練が進むにつれて適切な更新量に自動調整される。


以上のことから、AdaDeltaでは、学習率 $$\eta$$ が更新式に含まれておらず、代わりに過去のパラメータ更新のRMS （$$\text{RMS}[\Delta w]_i^{(\tau-1)}$$ ）が学習率の役割を果たしていることが分かる。



## Adam（Adaptive Moments）

2014年には、RMSProp と Momentum を組み合わせた Adam が提案された。
Adamは各パラメータに対して、勾配の指数加重移動平均 $$s_i$$ と、二乗勾配の指数加重移動平均 $$r_i$$ を別々に維持し、両方を利用して更新式を設定する。

### 更新式

勾配の一次モーメント（平均）の推定：


$$
s_i^{(\tau)} = \beta_1 s_i^{(\tau-1)} + (1 - \beta_1) \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)
$$

勾配の二次モーメント（分散）の推定：


$$
r_i^{(\tau)} = \beta_2 r_i^{(\tau-1)} + (1 - \beta_2) \left( \frac{\partial E(\mathbf{w})}{\partial w_i} \right)^2
$$

バイアス補正：


$$\hat{s}_i^{(\tau)} = \frac{s_i^{(\tau)}}{1 - \beta_1^{\tau}}$$

$$\hat{r}_i^{(\tau)} = \frac{r_i^{(\tau)}}{1 - \beta_2^{\tau}}$$

パラメータ更新：


$$w_i^{(\tau)} = w_i^{(\tau-1)} - \eta \frac{\hat{s}_i^{(\tau)}}{\sqrt{\hat{r}_i^{(\tau)}} + \delta}$$


#### 一次モーメント 

$$s_i$$ は勾配の指数加重移動平均であり、過去の勾配情報を蓄積して勾配の方向が一貫している場合は更新が加速され、方向が頻繁に変わる場合は更新が減衰されるという、Momentum と同様のはたらきがある。

#### 二次モーメント

$$r_i$$ は二乗勾配の指数加重移動平均であり、RMSPropと同じ役割を果たす。これにより、各パラメータに対して適切な学習率を設定することができる。
更新式では、$$\hat{s}_i$$ を、二次モーメントと学習率を利用し、 $$\eta / (\sqrt{\hat{r}_i} + \delta)$$ でスケーリングする。


#### バイアス補正

Adamでは、勾配の一次モーメント（平均）と二次モーメント（分散）を指数加重移動平均で推定しており、勾配を$$g_i$$とすると、以下のように書ける。


$$s_i^{(\tau)} = \beta_1 s_i^{(\tau-1)} + (1 - \beta_1) g_i^{(\tau)}$$

$$r_i^{(\tau)} = \beta_2 r_i^{(\tau-1)} + (1 - \beta_2) (g_i^{(\tau)})^2$$


これらの移動平均を $$s_i^{(0)} = 0$$、$$r_i^{(0)} = 0$$ で初期化すると、初期の推定値が真の値よりも小さくなってしまうという問題が生じる。


- 移動平均の展開

$$s_i^{(0)} = 0$$ として、最初の数ステップを展開する。


$$s_i^{(1)} = \beta_1 \cdot 0 + (1 - \beta_1) g_i^{(1)} = (1 - \beta_1) g_i^{(1)}$$

$$s_i^{(2)} = \beta_1 s_i^{(1)} + (1 - \beta_1) g_i^{(2)} = \beta_1 (1 - \beta_1) g_i^{(1)} + (1 - \beta_1) g_i^{(2)}$$

$$s_i^{(3)} = \beta_1^2 (1 - \beta_1) g_i^{(1)} + \beta_1 (1 - \beta_1) g_i^{(2)} + (1 - \beta_1) g_i^{(3)}$$

一般に、時刻 $$\tau$$ では


$$
s_i^{(\tau)} = (1 - \beta_1) \sum_{k=1}^{\tau} \beta_1^{\tau - k} g_i^{(k)}
$$

- 期待値の計算

勾配 $$g_i^{(k)}$$ が同じ分布から独立に得られ、期待値 $$\mathbb{E}[g_i] = \mu$$ を持つと仮定する。

$$s_i^{(\tau)}$$ の期待値は、


$$
\mathbb{E}[s_i^{(\tau)}] = (1 - \beta_1) \sum_{k=1}^{\tau} \beta_1^{\tau - k} \mathbb{E}[g_i^{(k)}] = (1 - \beta_1) \mu \sum_{k=1}^{\tau} \beta_1^{\tau - k}
$$

- 等比級数の和

$$\sum_{k=1}^{\tau} \beta_1^{\tau - k}$$ は等比級数の和である。$$j = \tau - k$$ と置換すると、


$$
\sum_{k=1}^{\tau} \beta_1^{\tau - k} = \sum_{j=0}^{\tau-1} \beta_1^j = \frac{1 - \beta_1^{\tau}}{1 - \beta_1}
$$

したがって、


$$
\mathbb{E}[s_i^{(\tau)}] = (1 - \beta_1) \mu \cdot \frac{1 - \beta_1^{\tau}}{1 - \beta_1} = \mu (1 - \beta_1^{\tau})
$$

- バイアス

真の期待値は $$\mu$$ であるが、推定値の期待値は $$\mu (1 - \beta_1^{\tau})$$ になった。
つまり、係数 $$(1 - \beta_1^{\tau})$$ のぶんだけバイアスが生じており、$$\beta_1^{\tau}$$ が1より小さいため、推定値は真の値より小さくなることが分かる。このバイアスを打ち消すために、補正が必要となる。


例えば $$\beta_1 = 0.9$$ の場合のバイアスは、以下のようになる。特に訓練初期では推定値が真の値よりも小さく評価されてしまい、実効学習率に大きな影響を与えることが分かる。

|時刻 $$\tau$$|$$(1 - \beta_1^{\tau})$$|バイアスの程度|
|---|---|---|
|1|$$1 - 0.9 = 0.1$$|真の値の10%しか推定されない|
|2|$$1 - 0.81 = 0.19$$|真の値の19%|
|5|$$1 - 0.59 = 0.41$$|真の値の41%|
|10|$$1 - 0.35 = 0.65$$|真の値の65%|
|50|$$1 - 0.005 \approx 0.995$$|ほぼ100%|


{: .prompt-tip }
> **Summary**
> - **Momentum の課題**: 標準的な勾配降下法は全パラメータに同一の学習率を使用するため、曲率の異なる方向に対して最適な学習率を設定できない。
> - **AdaGrad**: 各パラメータの勾配の二乗を累積し、累積値が大きいほど学習率を下げる。ただし、累積値が単調増加するため、訓練後半で学習率が過度に小さくなる問題がある。
> - **RMSProp**: AdaGrad の累積和を指数加重平均に置き換え、古い勾配情報を減衰させることで学習率の過度な減少を防ぐ。
> - **AdaDelta**: RMSProp と同様に指数加重平均を使用しつつ、パラメータ更新量の RMS を学習率の代わりに用いることで、明示的な学習率設定を不要にした。
> - **Adam**: RMSProp と Momentum を組み合わせ、勾配の一次モーメント（方向の一貫性）と二次モーメント（適応的学習率）の両方を活用。ゼロ初期化によるバイアスを補正する仕組みも持つ。



---

## Random Thoughts

1. ちゃじぴに色々聞きながら書いていると、最近はAdamのバイアス項はLearning rate schedulerでいうところのウォームアップをしているだけだというアーカイブが出ていることを教えてくれました。バイス項を消して、LLMで経験的にうまくいくことが知られているSchedulerを使えば、同じようにLossが収束したそうです[^1]。

2. 論文ではAdamしか見かけないので、RMSPropとMomentumの組み合わせが覇権を握ったわけですが、AdaDeltaとMomentumの組み合わせが流行らなかったのはなぜなんでしょうかね。Adamと違って初期値に工夫がないから？と思ったらバイアス補正は学習率Schedulerと同じだと言われていたり、Pytorchに実装[^2]はありますが、lrを設定しないのがウリなのにoptionalとはいえlrを設定できるようにしていたり、よく分かりませんでした。

---

## Reference


[^1]: Laing, S., & Orvieto, A. (2025). Adam Simplified: Bias Correction Debunked. arXiv:2511.20516. https://arxiv.org/abs/2511.20516

[^2]: https://docs.pytorch.org/docs/stable/generated/torch.optim.Adadelta.html accessed on 2026-01-11.